template <int dim>
void Problem<dim>::compute_updated_quadrature_point_data (
    Tensor<2, dim> F, // Deformation gradient
    std::shared_ptr<PointHistory<dim>> point_history,
    [[maybe_unused]] unsigned int q, // For debugging 
    // The following are output variables all imported by reference. The
    // results of the quadrature point update are written into these
    // variables.The values for the previous time step are passed in as input
    // in the point_history variable.
    Tensor<2, dim> &F_B,
    Tensor<2, dim> &F_D,
    SymmetricTensor<2, dim> &T_A,
    SymmetricTensor<4, dim> &Jc
) {

    SymmetricTensor<2, dim> I = Physics::Elasticity::StandardTensors<dim>::I;

    // Trial elastic state. Assume no viscous flow and these strain tensors
    // just take their values from the previous time step.
    Tensor<2, dim> F_B_trial = point_history->F_B;
    Tensor<2, dim> F_D_trial = point_history->F_D;

    // The tensors *old, *new and are related to different estimates of the
    // tensors F_B and F_D within the iteration loop
    Tensor<2, dim> F_B_old = F_B_trial;
    Tensor<2, dim> F_D_old = F_D_trial;
    Tensor<2, dim> F_B_new;
    Tensor<2, dim> F_D_new;

    // Estimates of the rates of change of the tensors F_B and F_D
    Tensor<2, dim> F_B_dot;
    Tensor<2, dim> F_D_dot;

    // List of the other tensors and scalars involved in the constitutive update
    double lambda;
    double f_R;
    double gamma_dot_B;

    Tensor<2, dim> F_A; 
    Tensor<2, dim> F_C;

    SymmetricTensor<2, dim> B_bar_A;
    SymmetricTensor<2, dim> C_A;
    SymmetricTensor<2, dim> T_A_dev;
    /*SymmetricTensor<2, dim> T_A;*/
    SymmetricTensor<2, dim> S_A;
    SymmetricTensor<2, dim> E_C;
    SymmetricTensor<2, dim> S_C;
    SymmetricTensor<2, dim> T_C;
    /*SymmetricTensor<2, dim> T_B;*/
    /*SymmetricTensor<2, dim> T_B_dev;*/
    SymmetricTensor<2, dim> S_B;
    SymmetricTensor<2, dim> S_B_dev;
    SymmetricTensor<2, dim> N_B;
    /*SymmetricTensor<2, dim> D_tilde_B;*/
    SymmetricTensor<2, dim> D_B;
    SymmetricTensor<2, dim> E_E;
    SymmetricTensor<2, dim> S_E;
    SymmetricTensor<2, dim> S_D;
    SymmetricTensor<2, dim> D_tilde_D;

    // Set the iteration counter for the consituttive update to zero
    int local_iterations = 0;

    // Volumetric response is purely elastic
    double J = determinant(F);
    SymmetricTensor<2, dim> T_A_vol = K * log((J - f_1)/(1 - f_1)) * I;

    // Start of constitutive integration loop
    while (true) {

        // Compute T_A
        F_A     = F * invert(F_B_old);
        B_bar_A = pow(J, -2/3) * symmetrize(F_A * transpose(F_A));
        lambda  = sqrt(trace(B_bar_A) / 3);
        T_A_dev = (mu_0 / J)
                * (lambda_L / lambda)
                * inverse_Langevin(lambda / lambda_L)
                * deviator(B_bar_A);
        T_A     = T_A_vol + T_A_dev;
        S_A     = J * Physics::Transformations::Contravariant::pull_back(T_A, F_A);

        // Compute T_C
        F_C = F_B_old * invert(F_D_old);
        E_C = HenckyStrain(F_C);
        S_C = 2 * G_0 * E_C;
        /*T_C = (1/J) * symmetrize(F_A * S_C * transpose(F_A));*/

        // Compute stresses for element B and direction of driving stress
        /*T_B     = T_A - T_C;*/
        /*T_B_dev = deviator(T_B);*/
        /*N_B     = T_B_dev / sqrt(T_B_dev * T_B_dev);*/
        S_B     = S_A - S_C;
        C_A     = symmetrize(transpose(F_A) * F_A);
        S_B_dev = S_B - (invert(C_A) * S_B) * C_A / 3;
        N_B     = S_B_dev / sqrt(S_B_dev * S_B_dev);

        /*if (q == 0) {*/
        /*    std::cout << "S_B = " << S_B << std::endl;*/
        /*    std::cout << "S_B_dev = " << S_B_dev << std::endl;*/
        /*}*/

        // Compute rate for F_B
        f_R = pow(alpha, 2)
            / pow(alpha + sqrt(trace(F_B_old * transpose(F_B_old))/3) - 1, 2);

        gamma_dot_B = gamma_dot_0
                    * f_R
                    * pow(sqrt(S_B_dev * S_B_dev) / (sqrt(2) * sigma_0) , np);
        /*D_tilde_B   = gamma_dot_B * N_B;*/
        D_B     = gamma_dot_B * N_B;
        F_B_dot = D_B * F_B_old;

        // Compute new F_B
        F_B_new = F_B_trial + F_B_dot * delta_t;
        F_B_new = F_B_new * pow(determinant(F_B_new), -1/3);

        // Computer S_E and S_D
        E_E = HenckyStrain(F_D_old);
        S_E = 2 * G_infinity * E_E;
        S_D = S_C - symmetrize(F_C * S_E * transpose(F_C));

        // Compute new F_D
        D_tilde_D = S_D / (sqrt(2) * eta);
        F_D_dot   = invert(F_C) * D_tilde_D * F_B_old;
        F_D_new   = F_D_trial + F_D_dot * delta_t;
        F_D_new   = F_D_new * pow(determinant(F_D_new), -1/3);

        if (local_iterations == max_no_of_local_iterations) {

            std::cout << "Too many constitutive update iterations."
                      << "Exiting program."
                      << std::endl;

            exit(0);
        }

        ++local_iterations;

        if ((F_B_new - F_B_old).norm() < 1e-15
            and
            (F_D_new - F_D_old).norm() < 1e-15) {

            F_B = F_B_new;
            F_D = F_D_new;

            Jc = compute_tangent_modulus(
                    F,
                    F_A,
                    F_B_trial,
                    D_B,
                    delta_t,
                    f_R,
                    S_B,
                    S_B_dev);

            return;

        } else {

            F_B_old = F_B_new;
            F_D_old = F_D_new;

        }

    } // End of constitutive integration loop

}
